# 内部仕様書: イベント管理システム

## 概要

本文書は、サークル内利用を想定したイベント管理システムの完全版内部仕様を定義するものです。ドメインモデルとアーキテクチャ原則に基づき、バックエンドからフロントエンドに至るまで、システムの全階層にわたる詳細な設計図と具体的な実装ブループリントを提供します。

## 第 1 部: ドメイン駆動設計：コアビジネスロジック

本セクションでは、システムの概念的基盤を確立します。厳格なユビキタス言語を定義し、リッチで振る舞いを持つ集約を用いてドメインをモデリングします。

### 1.1. ユビキタス言語

本プロジェクトにおいて、開発者とコードの間で共有される共通言語を以下のように定義します。

#### 表 1.1: ユビキタス言語の用語集

| 用語           | 英語表記          | 説明                                                                                                                        |
| -------------- | ----------------- | --------------------------------------------------------------------------------------------------------------------------- |
| ユーザー       | User              | システムを利用するすべての人。認証は外部で行われ、役割(Role)と世代(Generation)を持つ。User オブジェクトとしてモデル化。     |
| イベント       | Event             | システムが管理する中心的な対象物（例会、合宿など）。Event 集約としてモデル化される。                                        |
| 主催者         | Organizer         | イベントを作成・管理するユーザー。特定の Event オブジェクトの属性として記録される機能的な役割であり、固定の Role ではない。 |
| 参加登録       | Registration      | あるユーザーが、あるイベントに参加することを示す関係性。Registration 集約としてモデル化される。                             |
| 日程調整       | SchedulePoll      | イベントの日時を決めるための機能。Event 集約内部のエンティティとしてモデル化される。                                        |
| 料金設定       | FeeSetting        | 特定の役割・世代に対する料金ルール。Event 集約内部のエンティティとしてモデル化される。                                      |
| 集約           | Aggregate         | 一貫性の境界を定義する DDD の構成要素。トランザクションの単位。例：Event 集約。                                             |
| エンティティ   | Entity            | 集約の内部に存在し、一意な識別子を持つオブジェクト。例：FeeSetting エンティティ。                                           |
| 値オブジェクト | Value Object (VO) | 属性値によって定義される不変のオブジェクト。例：Money, EventStatus。                                                        |
| コマンド       | Command           | システムの状態を変更する意図を表すオブジェクト。例：CreateEventCommand。                                                    |
| クエリ         | Query             | システムの状態を変更せず、データを取得するための操作。例：GetEventDetailsQuery。                                            |
| 不変条件       | Invariant         | 集約が常に維持しなければならないビジネスルール。                                                                            |

### 1.2. ドメインモデル：集約、エンティティ、値オブジェクト

ここまでの対話で確定した、本システム固有のドメインモデルを以下に示します。

#### User オブジェクト

**説明**: システムを利用するすべての人。認証は外部サービスで行います。ユーザーの Role と Generation が、イベントへの参加資格や料金を決定する際の重要な情報となります。

**属性**:

- UserID (外部サービスから連携される ID)
- Name (名前)
- Role (役割: CircleAdmin, RegularMember, Alumni, External など)
- Generation (世代: "2023", "2024" など。文字列型)

**振る舞い**: なし (ユーザー情報は外部で管理)

#### Event 集約 (Aggregate)

**説明**: システムで管理される中心的な集約ルート。このオブジェクトが、イベントに関するすべての情報とビジネスルールを保持します。

**属性**:

- EventID (UUID): 集約の一意な識別子。
- Organizer (User Reference): このイベントを作成した User への参照。
- Title (string): イベント名。
- Description (string): 詳細な説明。
- Status (EventStatus VO): イベントのライフサイクル状態。
- AllowedRoles (Role[]): 参加を許可する役割のリスト。
- Tags (Tag[]): タグのリスト。
- Venue (string): 会場情報。
- SchedulePoll (SchedulePoll Entity): 日程調整情報。
- FeeSettings (FeeSetting[]): 料金設定のリスト。
- Comments (Comment[]): コメントのリスト。
- EventReports (EventReport[]): イベント記録のリスト。

**振る舞い**:

- CreateDraft(): 下書きイベントを作成する。
- UpdateDetails(): イベント情報を編集する。
- StartSchedulePolling(): 日程調整を開始する。
- ConfirmSchedule(finalDate): 開催日時を確定する。
- Publish(): 参加者募集を開始する。
- Cancel(): イベントをキャンセルする。
- Finish(): イベントを終了済みにする。
- AddComment(): コメントを追加する。
- GetApplicableFee(user): 特定のユーザーに適用される料金を決定して返す。

#### Registration 集約 (Aggregate)

**説明**: あるユーザーが、あるイベントに参加することを示す関係性。どの料金が適用されたかも記録します。

**属性**:

- RegistrationID (UUID): 集約の一意な識別子。
- Event (Event Reference): 参加するイベントへの参照。
- User (User Reference): 参加するユーザーへの参照。
- Status (RegistrationStatus VO): 登録状態 (REGISTERED, CANCELLED)。
- AppliedFee (Money VO): 適用された料金。

**振る舞い**:

- Cancel(): 参加登録をキャンセルする。

#### コアエンティティ（Event 集約内部）

- **SchedulePoll エンティティ**: 日程調整機能。
  - 状態: PollType, CandidateDates, Responses, FinalizedDate。
- **FeeSetting エンティティ**: 役割・世代ごとの料金ルール。
  - 状態: ApplicableRole, ApplicableGeneration, Fee (Money VO)。

#### コア値オブジェクト (Value Objects)

- **EventStatus**: イベントのライフサイクルを表す列挙型 (DRAFT, SCHEDULE_POLLING, CONFIRMED, FINISHED, CANCELLED)。
- **Money**: 金額と通貨を扱うオブジェクト。

### 1.3. 集約の不変条件

集約が常に一貫した状態を保つために強制しなければならないビジネスルールです。

#### 表 1.2: 集約の不変条件

| 集約         | 不変条件                                                                             | ビジネス上の正当性                                                       |
| ------------ | ------------------------------------------------------------------------------------ | ------------------------------------------------------------------------ |
| Event        | 公開（Publish）時、日程調整が完了し、開催日時が確定していなければならない。          | 開催日時未定のイベントで参加者を募集する混乱を防ぐため。                 |
| Event        | 公開時、イベントの開始日は過去であってはならない。                                   | 過去のイベントを公開することは無意味であるため。                         |
| Event        | 一度キャンセルされたイベントは、再度公開することはできない。                         | キャンセルされたイベントが誤って再開されることによる混乱を防ぐため。     |
| Event        | 日程調整の回答は、許可された役割(AllowedRoles)を持つユーザーのみ行える。             | イベントに参加資格のないユーザーが日程調整に影響を与えることを防ぐため。 |
| Registration | イベントへの参加登録は、Event の AllowedRoles に含まれる役割を持つ User のみ行える。 | イベントの参加対象者を制限するため。                                     |

## 第 2 部: システムユースケース：CQRS 実装

### 2.1. コマンドモデル（書き込み操作）

#### 表 2.1: コマンド仕様

| コマンド名         | 英語表記                  | 説明                                                           | パラメータ                                                                                                        | 対象集約            |
| ------------------ | ------------------------- | -------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- | ------------------- |
| イベント作成       | CreateEventCommand        | 新しいイベントを作成し、日程調整を開始する。                   | { Title, Description, Venue, AllowedRoles, Tags, FeeSettings, PollCandidates } (主催者 UserID は認証情報から取得) | Event               |
| イベント情報更新   | UpdateEventDetailsCommand | 既存のイベントの基本情報（名称、説明、料金設定等）を更新する。 | { EventID, Title, Description, ... }                                                                              | Event               |
| イベント公開       | PublishEventCommand       | 日程確定済みのイベントを公開し、参加登録を受け付け可能にする。 | { EventID }                                                                                                       | Event               |
| イベントキャンセル | CancelEventCommand        | 公開中のイベントをキャンセルする。                             | { EventID, Reason }                                                                                               | Event               |
| 日程調整回答       | RespondToPollCommand      | ユーザーが日程調整の候補日に回答する。                         | { EventID, Responses } (UserID は認証情報から取得)                                                                | Event               |
| 日程確定           | FinalizeScheduleCommand   | 主催者がイベントの開催日時を最終決定する。                     | { EventID, FinalizedDate }                                                                                        | Event               |
| イベント参加登録   | RegisterForEventCommand   | ユーザーがイベントに参加登録する。                             | { EventID } (UserID は認証情報から取得)                                                                           | Registration, Event |
| 参加登録キャンセル | CancelRegistrationCommand | ユーザーがイベントへの登録をキャンセルする。                   | { RegistrationID }                                                                                                | Registration, Event |

### 2.2. クエリモデル（読み取り操作）

#### 表 2.2: クエリおよび DTO 仕様

| クエリ名             | 英語表記             | 説明                                                       | パラメータ                                  | 返却 DTO                         |
| -------------------- | -------------------- | ---------------------------------------------------------- | ------------------------------------------- | -------------------------------- |
| イベント一覧取得     | ListEventsQuery      | ユーザーが閲覧可能なイベントを一覧取得する。               | { Page, PageSize, StatusFilter, TagFilter } | PaginatedResult<EventSummaryDTO> |
| イベント詳細取得     | GetEventDetailsQuery | 単一イベントの完全な詳細情報を取得する。                   | { EventID }                                 | EventDetailsDTO                  |
| マイイベント一覧取得 | ListMyEventsQuery    | 自分が参加登録した、または作成したイベントを一覧取得する。 | { Page, PageSize }                          | PaginatedResult<EventSummaryDTO> |

## 第 3 部: API 契約：OpenAPI v3.1 仕様

`/docs/api/openapi.yaml` に配置される、システムの API 契約です。

```yaml
openapi: 3.1.0
info:
  title: Circle Event Management System API
  version: "1.0.0"
servers:
  - url: http://localhost:8080/api/v1
paths:
  /events:
    get:
      summary: List Events
      operationId: listEvents
      tags: [Events]
      security: [{ bearerAuth: [] }]
      parameters:
        - name: page
          in: query
          schema: { type: integer, default: 1 }
        - name: pageSize
          in: query
          schema: { type: integer, default: 20 }
      responses:
        "200":
          description: A paginated list of events.
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/PaginatedEventSummary"
    post:
      summary: Create a new Event
      operationId: createEvent
      tags: [Events]
      security: [{ bearerAuth: [] }]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/CreateEventCommand"
      responses:
        "201":
          description: Event created successfully
          content:
            application/json:
              schema:
                type: object
                properties: { eventId: { type: string, format: uuid } }

  /events/{eventId}:
    get:
      summary: Get Event Details
      operationId: getEventDetails
      tags: [Events]
      security: [{ bearerAuth: [] }]
      parameters:
        - {
            name: eventId,
            in: path,
            required: true,
            schema: { type: string, format: uuid },
          }
      responses:
        "200":
          description: Detailed information for a single event.
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/EventDetailsDTO"

  /events/{eventId}/register:
    post:
      summary: Register for an Event
      operationId: registerForEvent
      tags: [Registrations]
      security: [{ bearerAuth: [] }]
      parameters:
        - {
            name: eventId,
            in: path,
            required: true,
            schema: { type: string, format: uuid },
          }
      responses:
        "201":
          description: Registration successful
          content:
            application/json:
              schema:
                type: object
                properties: { registrationId: { type: string, format: uuid } }

components:
  schemas:
    # --- Commands ---
    CreateEventCommand:
      type: object
      properties:
        title: { type: string, example: "新歓合宿" }
        description: { type: string, example: "春の新歓合宿です！" }
        venue: { type: string, example: "奥多摩" }
        allowedRoles:
          type: array
          items:
            {
              type: string,
              enum: [CircleAdmin, RegularMember, Alumni, External],
            }
        tags:
          type: array
          items: { type: string }
        feeSettings:
          type: array
          items:
            $ref: "#/components/schemas/FeeSettingInput"
        pollCandidates:
          type: array
          items: { type: string, format: "date-time" }
      required: [title]

    FeeSettingInput:
      type: object
      properties:
        applicableRole: { type: string }
        applicableGeneration: { type: string, nullable: true }
        fee: { $ref: "#/components/schemas/Money" }

    # --- DTOs ---
    EventSummaryDTO:
      type: object
      properties:
        id: { type: string, format: uuid }
        title: { type: string }
        finalizedDate: { type: string, format: date-time, nullable: true }
        status: { $ref: "#/components/schemas/EventStatus" }
        organizerName: { type: string }

    EventDetailsDTO:
      type: object
      properties:
        id: { type: string, format: uuid }
        title: { type: string }
        description: { type: string }
        status: { $ref: "#/components/schemas/EventStatus" }
        organizer: { $ref: "#/components/schemas/UserSummaryDTO" }
        schedulePoll: { $ref: "#/components/schemas/SchedulePollDTO" }
        feeSettings:
          type: array
          items: { $ref: "#/components/schemas/FeeSettingInput" }
        # ... commentsなど、その他の詳細情報

    UserSummaryDTO:
      type: object
      properties:
        userId: { type: string }
        name: { type: string }
        generation: { type: string }

    SchedulePollDTO:
      type: object
      properties:
        pollId: { type: string }
        pollType: { type: string }
        candidateDates:
          { type: array, items: { type: string, format: "date-time" } }
        responses:
          {
            type: array,
            items: { $ref: "#/components/schemas/PollResponseDTO" },
          }

    # --- Value Objects & Common ---
    Money:
      type: object
      properties:
        amount: { type: integer }
        currency: { type: string, default: "JPY" }
    EventStatus:
      type: string
      enum: [DRAFT, SCHEDULE_POLLING, CONFIRMED, FINISHED, CANCELLED]
    PaginatedEventSummary:
      type: object
      # ...

  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
```

## 第 4 部: バックエンド実装ブループリント (/backend - Go)

バックエンドの実装は、クリーンアーキテクチャの原則と標準的な Go プロジェクトレイアウトに厳密に従います。

### 4.1. アプリケーション層 (/internal/application/command/create_event.go)

コマンドハンドラは、認証情報から取得した UserID を使い、ドメインロジックを呼び出します。

```go
package command

import (
    "context"
    "your_project_path/internal/domain/aggregate"
    "your_project_path/internal/domain/repository"
)

type CreateEventCommandHandler struct {
    eventRepo repository.EventRepository
    userRepo  repository.UserRepository
}

// Handle はコマンドを実行します。
func (h *CreateEventCommandHandler) Handle(ctx context.Context, cmd CreateEventCommand, userID string) (string, error) {
    // 1. userID を使って User オブジェクトを取得
    organizer, err := h.userRepo.FindByID(ctx, userID)
    if err != nil {
        return "", err // ユーザーが存在しないエラー
    }

    // 2. Event集約のファクトリ関数を呼び出す
    event, err := aggregate.NewEvent(organizer, cmd.Title, /* ...その他の引数... */)
    if err != nil {
        return "", err
    }

    // 3. リポジトリで永続化
    if err := h.eventRepo.Save(ctx, event); err != nil {
        return "", err
    }

    return event.ID, nil
}
```

### 4.2. インターフェース層 (/internal/interface/handler/event_handler.go)

HTTP ハンドラは、JWT トークンから UserID を抽出し、コマンドハンドラに渡します。

```go
package handler

import (
    "github.com/labstack/echo/v4"
    "net/http"
    "your_project_path/internal/application/command"
    "your_project_path/internal/interface/api"
    "your_project_path/internal/interface/middleware"
)

// CreateEvent (POST /events) はイベント作成リクエストを処理します。
func (s *Server) CreateEvent(c echo.Context) error {
    var req api.CreateEventCommand
    if err := c.Bind(&req); err != nil {
        return c.JSON(http.StatusBadRequest, "Invalid request body")
    }

    // ミドルウェアによってセットされたJWTクレームからUserIDを取得
    claims := middleware.GetClaims(c)
    userID := claims.UserID

    cmd := command.CreateEventCommand{
        Title: req.Title,
        // ... リクエストボディからコマンドへマッピング ...
    }

    eventID, err := s.createEventCmdHandler.Handle(c.Request().Context(), cmd, userID)
    if err != nil {
        return c.JSON(http.StatusInternalServerError, err.Error())
    }

    return c.JSON(http.StatusCreated, map[string]string{"eventId": eventID})
}
```

## 第 5 部: フロントエンド実装ブループリント (/frontend - Next.js)

フロントエンドは、ユーザー指定の「実用的な MVVM」パターンを採用します。これは、React の現代的なパラダイムに沿った、カスタムフックを ViewModel として利用するアプローチです。

### 5.1. コアライブラリと設定

**状態管理**:

- **TanStack Query**: サーバー状態（API データ）のフェッチ、キャッシング、非同期更新を管理。
- **Zustand**: クライアント状態（モーダルの開閉、フォーム入力値など）をシンプルに管理。

**UI コンポーネント**:

- **Tailwind CSS**: ユーティリティファーストな CSS フレームワーク。
- **shadcn/ui**: Tailwind CSS をベースにした、コピー＆ペーストで利用可能なアクセシブルな UI コンポーネント集。Button, Input, Card などを提供。

**API クライアント**:

- **openapi-ts**: openapi.yaml から型安全な Axios クライアントを自動生成。

### 5.2. TanStack Query プロバイダー設定

アプリケーションのルートレイアウトでプロバイダーを設定し、アプリ全体で利用可能にします。

`/src/lib/query-provider.tsx`

```tsx
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { useState } from "react";

export default function QueryProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const [queryClient] = useState(() => new QueryClient());

  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

### 5.3. ユースケース実装例：新規イベント作成

#### 5.3.1. ViewModel (`_viewmodels/useCreateEventViewModel.ts`)

状態管理とビジネスロジックをカプセル化します。

```tsx
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useRouter } from "next/navigation";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { api } from "@/lib/api"; // 自動生成された API クライアント
import { CreateEventCommand } from "@/lib/api/models"; // 自動生成された型

// Zod でフォームのバリデーションスキーマを定義
const createEventSchema = z.object({
  title: z
    .string()
    .min(3, { message: "タイトルは 3 文字以上で入力してください。" }),
  description: z.string().optional(),
  // ... venue, allowedRoles, feeSettings なども同様に定義
});

export const useCreateEventViewModel = () => {
  const router = useRouter();
  const queryClient = useQueryClient();

  // React Hook Form でフォームの状態とバリデーションを管理
  const form = useForm<z.infer<typeof createEventSchema>>({
    resolver: zodResolver(createEventSchema),
    defaultValues: { title: "", description: "" },
  });

  // TanStack Query の useMutation で API 呼び出しを定義
  const { mutate: createEvent, isPending } = useMutation({
    mutationFn: (data: CreateEventCommand) => api.createEvent({ body: data }),
    onSuccess: (data) => {
      // 成功時: キャッシュを無効化し、一覧を再取得させる
      queryClient.invalidateQueries({ queryKey: ["events"] });
      // 作成されたイベントの詳細ページにリダイレクト
      router.push(`/events/${data.eventId}`);
    },
    onError: (error) => {
      // エラーハンドリング (例: トースト通知)
      console.error("イベント作成に失敗しました:", error);
    },
  });

  // フォーム送信時のハンドラ
  const onSubmit = (values: z.infer<typeof createEventSchema>) => {
    // values を API が要求する CreateEventCommand の形式に変換
    const commandData: CreateEventCommand = { ...values };
    createEvent(commandData);
  };

  return {
    form,
    onSubmit: form.handleSubmit(onSubmit),
    isLoading: isPending,
  };
};
```

#### 5.3.2. View (`_components/EventForm.tsx` と `app/events/new/page.tsx`)

ViewModel から受け取った状態と関数を UI に結びつけます。

`/src/app/events/new/page.tsx`

```tsx
"use client";

import { EventForm } from "./_components/EventForm";
import { useCreateEventViewModel } from "./_viewmodels/useCreateEventViewModel";

export default function CreateEventPage() {
  const { form, onSubmit, isLoading } = useCreateEventViewModel();

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">新規イベント作成</h1>
      <EventForm form={form} onSubmit={onSubmit} isLoading={isLoading} />
    </div>
  );
}
```

`/src/app/events/new/_components/EventForm.tsx` (抜粋)

```tsx
import { useFormContext } from "react-hook-form";
import { Button } from "@/components/ui/button"; // shadcn/ui
import { Input } from "@/components/ui/input";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";

export const EventForm = ({ form, onSubmit, isLoading }) => {
  return (
    <Form {...form}>
      <form onSubmit={onSubmit} className="space-y-8">
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormLabel>イベントタイトル</FormLabel>
              <FormControl>
                <Input placeholder="例: 夏合宿" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        {/* description, venue などの他のフィールドも同様に作成 */}
        <Button type="submit" disabled={isLoading}>
          {isLoading ? "作成中..." : "イベントを作成"}
        </Button>
      </form>
    </Form>
  );
};
```

## 第 6 部: UI/UX デザイン指針

### 6.1. デザインシステム

- **基盤**: Tailwind CSS を全面的に採用し、迅速なスタイリングを実現する。
- **コンポーネントライブラリ**: shadcn/ui を利用する。これにより、アクセシビリティと一貫性が確保された高品質な UI コンポーネント（Button, Card, Input, Form, Modal など）を効率的に構築できる。
- **カラースキーム**: シンプルでクリーンなカラースキームを基本とする。メインカラーに青、アクセントカラーに緑など、視認性の高い配色を選ぶ。
- **タイポグラフィ**: 可読性の高い日本語フォント（例: Noto Sans JP）をシステムフォントと組み合わせて利用する。

### 6.2. レイアウト

- **メインレイアウト**: サイドバーナビゲーションとメインコンテンツエリアで構成する。
- **サイドバー**: イベント一覧、イベント作成、マイページなどへのリンクを配置。
- **メインコンテンツ**: 各ページの主要な内容を表示。レスポンシブデザインを前提とし、モバイル端末でも快適に操作できるようにする。

### 6.3. ユーザーフロー

- **ログイン/認証**: 外部サービスによる認証後、システムにリダイレクトされる。
- **ダッシュボード**: ログイン後のトップページ。参加予定のイベントや、新着イベントの一覧を表示。
- **イベント作成**: イベント作成権限を持つユーザーは、フォームから新しいイベントを作成できる。
- **イベント一覧・検索**: 全ユーザーが、公開中のイベントを検索・閲覧できる。タグやステータスでの絞り込み機能を提供する。
- **イベント詳細**: イベントの詳細情報、日程調整の状況、コメントなどを閲覧できる。
- **参加登録**: 参加資格のあるユーザーは、詳細ページからイベントに参加登録できる。
