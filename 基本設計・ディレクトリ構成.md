# イベント管理システム

## 1.0 基本原則

### 1.1 エグゼクティブサマリー

本文書は、イベント管理システムのための、本番環境レベルで利用可能な包括的なテンプレートを定義するものです。このプロジェクトは、Go 言語によるバックエンドと Next.js によるフロントエンドを単一のリポジトリで管理するモノレポ構成を採用しています。そのアーキテクチャは、スケーラビリティ、保守性、そして開発速度を確保するため、現代的なソフトウェア設計原則を意図的に統合したものです。

### 1.2 アーキテクチャの相乗効果

本プロジェクトで採用されるアーキテクチャ原則は、単に個別で機能するだけでなく、互いに連携し相乗効果を生み出すように設計されています。

#### クリーンアーキテクチャ

これは、プロジェクト全体のマクロレベルの構造を規定し、「依存性のルール」を強制します。ビジネスロジックは、データベースやフレームワークのような技術的詳細から完全に隔離されます。このアーキテクチャの中心には domain 層が存在し、application 層と infrastructure 層が内側に向かって依存します。

#### ドメイン駆動設計 (DDD)

システムの中核となるビジネス概念（例: Event, Attendee, Venue）を、domain 層内で集約（Aggregate）、エンティティ（Entity）、値オブジェクト（Value Object）としてモデル化します。これにより、ビジネスルールを表現豊かで堅牢なモデルで実装することが可能になります。

#### コマンドクエリ責務分離 (CQRS)

システムを「書き込み」側（コマンド）と「読み取り」側（クエリ）に明確に分離します。CreateEventCommand のようなコマンドは、不変条件（invariants）を保証するためにリッチなドメインモデルを介して操作されます。一方、GetEventListQuery のようなクエリは、パフォーマンスを最適化するためにドメインモデルをバイパスし、データソースから直接シンプルな DTO（Data Transfer Object）を返却します。

#### イベント駆動アーキテクチャ (EDA)

コマンドによって状態が正常に変更された後、集約は EventPublished のようなドメインイベントを生成します。このイベントは、同じトランザクション内で同期的（例: Outbox パターンを使用）に処理されるか、あるいは他のサービスや境界づけられたコンテキストによる非同期処理のためにメッセージブローカーへ発行されます。これにより、コンポーネント間の疎結合性が高まり、スケーラビリティが向上します。

#### テスト駆動開発 (TDD)

開発は「レッド・グリーン・リファクタリング」のサイクルに従います。実装コードよりも先にテストを作成することで、インターフェースとロジックの設計を駆動します。これは、インターフェースが鍵となるクリーンアーキテクチャにおいて特に重要です。

#### Model-View-ViewModel (MVVM)

フロントエンドでは、このパターンが UI（View）をプレゼンテーションロジックと状態（ViewModel）から分離します。これにより、クライアントサイドアプリケーションのテスト容易性と組織構造が向上します。

### 1.3 アーキテクチャの相乗効果

これらの原則の組み合わせは、システム全体の堅牢性を飛躍的に高めます。例えば、CQRS はクリーンアーキテクチャの application 層への明確なエントリーポイント（コマンドとクエリ）を定義することで、自然に補完します。DDD は、domain 層の内部に存在するビジネスモデル、すなわち「何を」実装するのかを提供します。そして EDA は、集約間や境界づけられたコンテキスト間で密結合を生じさせることなく変更を伝達するための「どのように」という手段を提供します。

#### 処理フロー例

このアーキテクチャにおける一連の処理フローは以下のようになります：

1. ユーザー操作（例：「イベント作成」ボタンのクリック）が、フロントエンドの ViewModel でコマンドをトリガーします
2. コマンドはバックエンドの interface 層（API エンドポイント）に送信されます
3. API ハンドラは、そのコマンドを application 層にディスパッチします
4. application 層のコマンドハンドラは、リポジトリから関連する DDD の集約を取得します
5. ハンドラは集約のメソッドを呼び出し、ビジネスルール（不変条件）を適用します
6. 成功した場合、集約はドメインイベントを生成し、状態変更は infrastructure 層（リポジトリの実装）によって永続化されます
7. ドメインイベントは発行され（EDA）、他のプロセスをトリガーすることができます

この一連のフロー全体が、TDD とクリーンアーキテクチャの依存性注入の特性により、各層でテスト可能となります。このように、各原則が相互に作用し合うことで、堅牢なシステムが構築されます。

## 2.0 モノレポプロジェクト構成

### 2.1 合理的根拠

コード共有（特に型定義）、依存関係管理の簡素化、そしてフロントエンドとバックエンドにまたがるアトミックなコミットを可能にするため、モノレポ構成が選択されました。これにより、プロジェクト全体で単一の信頼できる情報源（Single Source of Truth）が提供されます。

### 2.2 ルートディレクトリツリー

```
event-management-system/
├── .github/                    # GitHub 関連ファイル（Issue テンプレート等）
├── .jenkins/                   # Jenkins 関連のスクリプトや設定
├── backend/                    # Go (Echo) バックエンドアプリケーション
├── frontend/                   # Next.js フロントエンドアプリケーション
├── packages/
│   └── shared-types/           # (任意だが推奨) 共有 TypeScript 型定義
├── docs/
│   └── api/
│       └── openapi.yaml        # API 契約の唯一の信頼できる情報源
├── .dockerignore
├── .gitignore
├── docker-compose.yml
├── Jenkinsfile
└── README.md
```

このモノレポ構造の要は、`/docs/api/openapi.yaml` ファイルです。これは単なるドキュメントではなく、フロントエンドとバックエンド間の整合性を強制する、コード生成を伴うアクティブな契約書として機能します。これにより、統合時のバグを未然に防ぐことができます。

#### 開発ワークフロー

この設計の背景には、明確な開発ワークフローがあります：

- **OpenAPI 統合**: フロントエンドとバックエンドの連携には OpenAPI を使用
- **コード生成**: `openapi-generator-cli` のようなツールは、単一の YAML ファイルからサーバーのスタブコードとクライアント SDK の両方を生成
- **中央管理**: `openapi.yaml` を中央の `docs/` ディレクトリに配置することで、「信頼できる情報源」として確立
- **CI/CD 統合**:
  - バックエンドの CI/CD ステージでは、この YAML ファイルを用いて Go のサーバーインターフェース（go-echo-server）を生成
  - フロントエンドの CI/CD ステージでは、同じくこの YAML ファイルから TypeScript のクライアント（typescript-axios）を生成

結果として、`openapi.yaml` 内のエンドポイントに変更が加えられると、両方のパイプラインがそれぞれのコードベースを更新するトリガーとなります。もしバックエンドが仕様を更新せずにエンドポイントを変更するなどの不整合が発生した場合、ビルドまたはテストが失敗し、エラーを早期に検出できます。このメカニズムにより、`openapi.yaml` ファイルはリポジトリ内で最も重要な統合ポイントとなります。

## 3.0 バックエンドアーキテクチャ (/backend)

### 3.1 ディレクトリレイアウト

大規模なアプリケーションで広く理解され、推奨されている標準的な Go のサーバープロジェクトレイアウトを採用します。

```
backend/
├── cmd/
│   └── api/
│       └── main.go             # Web サーバーのエントリーポイント
├── internal/
│   ├── application/            # ユースケース (コマンド/クエリ)
│   │   ├── command/
│   │   └── query/
│   ├── domain/                 # 中核となるビジネスロジック (集約、イベント)
│   │   ├── aggregate/
│   │   ├── entity/
│   │   ├── event/
│   │   └── vo/                 # 値オブジェクト (Value Objects)
│   ├── infrastructure/         # 実装 (DB、メッセージバス)
│   │   ├── persistence/        # GORM/sqlx リポジトリ
│   │   └── messaging/          # RabbitMQ/Kafka 実装
│   └── interface/              # 外部世界とのアダプタ
│       ├── api/                # 生成された OpenAPI サーバーインターフェース
│       └── handler/            # インターフェースを実装する Echo HTTP ハンドラ
├── pkg/                        # 共有される公開ライブラリ (もしあれば)
├── test/                       # E2E およびインテグレーションテスト
├── configs/                    # 設定ファイル (例: config.yaml)
├── migrations/                 # `goose`によるデータベースマイグレーション
├── go.mod
├── go.sum
└── Makefile
```

### 3.2 各層の責務

#### internal/domain

アプリケーションの心臓部。外部依存を一切持たない純粋なビジネスロジックを含みます。

**例**: `aggregate/event.go` は Event 集約を定義し、`Publish()` や `AddAttendee()` のようなメソッドを持ちます。これらのメソッドは、「満員のイベントに参加者を追加できない」といった不変条件を強制します。

#### internal/application

ドメインロジックをオーケストレーションし、ユースケースを定義します。

**例**: `command/create_event.go` は CreateEventCommand を処理し、EventRepository インターフェースと対話し、Event 集約のメソッドを呼び出します。

#### internal/infrastructure

application 層で定義されたインターフェースを実装します。データベースや外部サービスといった技術的な詳細がここに配置されます。

**例**: `persistence/event_mysql_repository.go` は、MySQL を使用して EventRepository インターフェースの具体的な実装を提供します。

#### internal/interface

アプリケーションを外部世界に接続します。

- **api/**: `openapi-generator-cli` によって生成されたコード（例: サーバーインターフェースを持つ api.go）が含まれます
- **handler/**: これらの生成されたインターフェースを実装する Echo ハンドラが含まれ、HTTP リクエストを application 層のコマンドやクエリに変換します

### 3.3 バックエンドレイヤーマッピング

クリーンアーキテクチャは抽象的になりがちですが、以下の表は開発者が各層の役割をひと目で理解し、アーキテクチャの一貫性を保つための具体的な指針となります。

| レイヤー       | ディレクトリ                | 責務                                                                                                     | コード例                          |
| -------------- | --------------------------- | -------------------------------------------------------------------------------------------------------- | --------------------------------- |
| Domain         | `/internal/domain/`         | 中核となるビジネスロジック、エンティティ、値オブジェクト、集約、ドメインイベント。フレームワーク非依存。 | `aggregate/event.go`              |
| Application    | `/internal/application/`    | ユースケース、CQRS ハンドラ、リポジトリ/ゲートウェイのインターフェース（ポート）。                       | `command/create_event.go`         |
| Interface      | `/internal/interface/`      | 外部からの入力に対するアダプタ。HTTP ハンドラ、DTO、生成されたサーバースタブ。                           | `handler/event_handler.go`        |
| Infrastructure | `/internal/infrastructure/` | ポートの具象実装。データベースアクセス、メッセージキュー、外部 API クライアント。                        | `persistence/event_mysql_repo.go` |

## 4.0 フロントエンドアーキテクチャ (/frontend)

### 4.1 ディレクトリレイアウト

現代的な Next.js アプリケーションのベストプラクティスとして、関連ファイルを一箇所にまとめる（colocation）ことで整理しやすさを向上させる、フィーチャーベースの構造を採用します。

```
frontend/
├── src/
│   ├── app/                    # App Router ルート
│   │   ├── (main)/             # メインアプリケーションルート (ダッシュボード等)
│   │   │   ├── events/
│   │   │   │   ├── [eventId]/
│   │   │   │   │   ├── _components/    # View: イベント詳細コンポーネント
│   │   │   │   │   ├── _viewmodels/    # ViewModel: useEventDetailViewModel.ts
│   │   │   │   │   └── page.tsx        # View: メインページコンポーネント
│   │   │   │   └── page.tsx
│   │   │   ├── layout.tsx
│   │   │   └── page.tsx                # ダッシュボード
│   │   ├── (auth)/             # 認証ルート (ログイン、サインアップ)
│   │   └── global-error.tsx
│   ├── components/             # グローバルな共有 UI コンポーネント (Button, Input 等)
│   ├── hooks/                  # グローバルな共有カスタムフック
│   ├── lib/
│   │   ├── api/                # 生成された OpenAPI クライアント
│   │   ├── query-provider.tsx  # TanStack Query プロバイダー設定
│   │   └── utils.ts            # ユーティリティ関数
│   ├── store/                  # Zustand グローバルストア
│   └── styles/                 # グローバルスタイル
├── public/
├── package.json
└── tsconfig.json
```

### 4.2 実用的な MVVM 実装

#### Model

「Model」層は、`openapi-ts` によって `src/lib/api/` に生成される TypeScript の型とスキーマによって表現されます。これにより、フロントエンドのモデルが常にバックエンドの API 契約と同期していることが保証されます。

#### View

これらは React コンポーネントです。初期データレンダリングにはサーバーコンポーネント（`page.tsx`）を、インタラクティブな UI 要素にはクライアントコンポーネント（`_components/*.tsx`）を使用します。クライアントコンポーネントはロジックをほとんど持たず（"dumb"）、主に ViewModel に処理を委任します。

#### ViewModel

これが最も重要な部分です。ViewModel はカスタム React フックとして実装します（例: `_viewmodels/useEventDetailViewModel.ts`）。このフックは以下の役割を担います：

- サーバーの状態管理（イベントデータのフェッチ、キャッシュ、更新）には TanStack Query を使用
- クライアントサイドの UI 状態（例: `isModalOpen`、フォームの入力値）には Zustand を使用
- 状態変数とハンドラ関数（例: `eventData`, `isLoading`, `handleUpdateEvent`）を View に公開
- `src/lib/api/` に生成された API クライアントと対話し、ネットワークリクエストを行います

#### 設計思想

このアプローチは、伝統的なクラスベースの MVVM パターンが React の関数型でフックベースのパラダイムとは相性が悪いという考察に基づいています。カスタムフックを ViewModel として利用する「実用的な MVVM」は、React の流儀に沿った現代的な解決策です。これにより、React の合成モデルの利点を活かしつつ、関心の分離という MVVM の本来の目的を達成できます。

## 5.0 API 契約とコード生成

### 5.1 openapi.yaml 契約

`/docs/api/openapi.yaml` に配置されるこのファイルが、唯一の信頼できる情報源です。すべてのエンドポイント、リクエスト/レスポンススキーマ、データ型を定義します。

### 5.2 バックエンド生成 (go-echo-server)

**ツール**: `openapi-generator-cli`

**コマンド**: Makefile のターゲットが生成処理を実行します。

```makefile
generate-api-server:
	openapi-generator-cli generate \
		-i ../docs/api/openapi.yaml \
		-g go-echo-server \
		-o internal/interface/api/ \
		--additional-properties=packageName=api
```

**出力**: `/backend/internal/interface/api/` に Go のインターフェース（例: ServerInterface）とモデルが生成されます。`/backend/internal/interface/handler/` 内の Echo ハンドラは、これらのインターフェースを実装します。

### 5.3 フロントエンド生成 (typescript-axios)

**ツール**: モダンで Next.js を特にサポートしている `@hey-api/openapi-ts` を使用します。代替として、標準的な `openapi-generator-cli` と `typescript-axios` の組み合わせも堅牢な選択肢です。

**コマンド**: `package.json` のスクリプトが生成処理を実行します。

```json
{
  "scripts": {
    "generate-api-client": "openapi-ts -i ../docs/api/openapi.yaml -o src/lib/api --client axios"
  }
}
```

**出力**: `/frontend/src/lib/api/` に、ViewModel からすぐに使用できる、完全に型付けされた API クライアントが生成されます。認証トークンを追加するためのインターセプターなど、Axios インスタンスをカスタマイズすることも可能です。

## 6.0 データベースとマイグレーション

### 6.1 ツール選定: goose

`pressly/goose` を使用します。`golang-migrate` よりも、Go ベースのマイグレーションの優れたサポートと、データベース内でのマイグレーション履歴のより良い追跡機能を持つため、こちらが選ばれました。この柔軟性は、ドメインロジックを必要とする可能性のある複雑なデータ移行において非常に価値があります。

### 6.2 マイグレーションワークフロー

マイグレーションファイルは `/backend/migrations/` に保存されます。バックエンドの Makefile が、開発者向けにシンプルなコマンドを提供します。

```makefile
DB_DSN="user:password@tcp(127.0.0.1:3306)/events_db?parseTime=true"

migrate-create:
	@if [ -z "$(NAME)" ]; then echo "NAME=マイグレーション名を指定してください"; exit 1; fi
	goose -dir ./migrations create $(NAME) sql

migrate-up:
	goose -dir ./migrations mysql "$(DB_DSN)" up

migrate-down:
	goose -dir ./migrations mysql "$(DB_DSN)" down

migrate-status:
	goose -dir ./migrations mysql "$(DB_DSN)" status
```

### 6.3 SQL マイグレーションの例

```sql
-- file: backend/migrations/00001_create_events_table.sql

-- +goose Up
CREATE TABLE events (
    id VARCHAR(36) NOT NULL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    start_date DATETIME NOT NULL,
    end_date DATETIME NOT NULL,
    status VARCHAR(50) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- +goose Down
DROP TABLE events;
```

## 7.0 開発環境

### 7.1 Docker Compose

ルートディレクトリにある `docker-compose.yml` ファイルが、開発環境を定義し、オーケストレーションします。

- **サービス**: frontend, backend, db (MySQL)
- **ネットワーキング**: カスタムブリッジネットワークにより、サービスがサービス名で通信できるようになります（例: バックエンドは `db:3306` に接続）
- **ボリューム**: frontend と backend のソースコードにはバインドマウントを使用し、開発中のホットリロードを可能にします。MySQL のデータ永続化には名前付きボリュームを使用します
- **ヘルスチェック**: backend サービスは、db が起動準備完了になるのを待ってから開始するために、`service_healthy` 条件付きの `depends_on` を使用します。これにより、接続エラーを防ぎます

### 7.2 docker-compose.yml 構造

```yaml
version: "3.9"

services:
  db:
    image: mysql:8.0
    container_name: event-management-db
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD:-rootpassword}
      MYSQL_DATABASE: ${DB_DATABASE:-events_db}
      MYSQL_USER: ${DB_USER:-events_user}
      MYSQL_PASSWORD: ${DB_PASSWORD:-events_password}
    ports:
      - "3306:3306"
    volumes:
      - db_data:/var/lib/mysql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.dev
    container_name: event-management-backend
    ports:
      - "8080:8080"
    volumes:
      - ./backend:/app
      - /app/vendor
    environment:
      - DB_HOST=db
      - DB_PORT=3306
      - DB_DATABASE=${DB_DATABASE:-events_db}
      - DB_USER=${DB_USER:-events_user}
      - DB_PASSWORD=${DB_PASSWORD:-events_password}
    depends_on:
      db:
        condition: service_healthy
    networks:
      - app-network

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.dev
    container_name: event-management-frontend
    ports:
      - "3000:3000"
    volumes:
      - ./frontend:/app
      - /app/node_modules
    environment:
      - NEXT_PUBLIC_API_URL=http://localhost:8080
    depends_on:
      - backend
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  db_data:
```

## 8.0 テスト戦略 (TDD)

### 8.1 バックエンド単体テスト

**ツール**: 流れるようなアサーションのための `testify/assert` と、リポジトリインターフェースからモックを生成するための `mockery` を使用します。

**プロセス**: アプリケーションサービス（例: CreateEventCommand）に対して、EventRepository インターフェースをモックしたテストを作成します。モックに対して期待する動作（例: `mockRepo.On("Save", mock.Anything).Return(nil)`）を設定し、コマンドハンドラを実行します。最後に、モックの期待が満たされたことと、結果が正しいことをアサートします。これにより、アプリケーションロジックがデータベースから隔離されます。

**テスト例** (`command/create_event_test.go`):

```go
package command_test

import (
    "context"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "your_project_path/internal/application/command"
    "your_project_path/internal/domain/aggregate"
    "your_project_path/internal/domain/mocks" // mockeryが生成したモック
)

func TestCreateEvent_Handle(t *testing.T) {
    mockRepo := new(mocks.EventRepository)

    // Saveメソッドが*aggregate.Event型の任意の引数で一度だけ呼び出され、
    // nilを返すことを期待する
    mockRepo.On("Save", mock.AnythingOfType("*aggregate.Event")).Return(nil).Once()

    usecase := command.NewCreateEventCommandHandler(mockRepo)
    cmd := command.CreateEventCommand{
        Name: "Test Event",
        // ...その他のフィールド
    }

    err := usecase.Handle(context.Background(), cmd)

    assert.NoError(t, err)
    mockRepo.AssertExpectations(t) // Saveが呼び出されたことを検証
}
```

### 8.2 フロントエンドコンポーネントテスト

**ツール**: コンポーネントのレンダリングとユーザーインタラクションのシミュレーションのための React Testing Library と、テストランナーとしての jest または vitest を使用します。

**プロセス**: `useEventViewModel` フックを使用するコンポーネントをテストするために、フック自体をモックします。これにより、コンポーネントに返される状態とハンドラを制御でき、UI を基礎となるロジックや API 呼び出しから隔離できます。その後、モックされた状態に基づいてコンポーネントが正しくレンダリングされること、およびユーザーの操作に応じて正しいハンドラ関数が呼び出されることをアサートできます。

**テスト例** (`_components/EventForm.test.tsx`):

```typescript
import { render, screen, fireEvent } from "@testing-library/react";
import { useEventViewModel } from "../_viewmodels/useEventViewModel";
import { EventForm } from "./EventForm";

// ViewModel フックをモックする
jest.mock("../_viewmodels/useEventViewModel");
const mockUseEventViewModel = useEventViewModel as jest.Mock;

test("フォーム送信時に handleCreate が呼び出されるべき", () => {
  const handleCreateMock = jest.fn();
  mockUseEventViewModel.mockReturnValue({
    event: { name: "", description: "" /*...*/ },
    isLoading: false,
    handleInputChange: jest.fn(),
    handleCreate: handleCreateMock,
  });

  render(<EventForm />);

  fireEvent.change(screen.getByLabelText(/Event Name/i), {
    target: { value: "New Conference" },
  });
  fireEvent.click(screen.getByRole("button", { name: /Create Event/i }));

  expect(handleCreateMock).toHaveBeenCalledTimes(1);
});
```

## 9.0 CI/CD パイプライン (Jenkinsfile)

### 9.1 モノレポ戦略

Jenkins パイプラインの中核は、ファイル変更に基づく条件付きのステージ実行です。これにより、ドキュメントの小さな変更のためにパイプライン全体を実行することを防ぎ、時間とリソースを節約します。宣言的な `when { changeset "..." }` ディレクティブを使用します。

### 9.2 パイプラインステージ

効率を最大化するため、パイプラインはフロントエンドとバックエンドの並列ステージで構成されます。

- **Checkout**: リポジトリをクローンします
- **並列ステージ (Backend & Frontend)**:
  - **Backend Stage**: `when { changeset "backend/**, docs/api/**" }`
    - ステップ: `make test`, `make build`, docker build
  - **Frontend Stage**: `when { changeset "frontend/**, docs/api/**" }`
    - ステップ: `npm install`, `npm run lint`, `npm test`, `npm run build`, docker build
- **Deploy**: ビルドされた Docker イメージをレジストリにデプロイし、その後ステージング/本番環境に展開するステージ

### 9.3 Jenkinsfile 構造

```groovy
pipeline {
    agent any

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Build & Test') {
            parallel {
                stage('Backend') {
                    when {
                        changeset "backend/**, docs/api/openapi.yaml"
                    }
                    steps {
                        dir('backend') {
                            sh 'make test'
                            sh 'make build'
                            echo 'Building backend Docker image...'
                        }
                    }
                }

                stage('Frontend') {
                    when {
                        changeset "frontend/**, docs/api/openapi.yaml"
                    }
                    steps {
                        dir('frontend') {
                            sh 'npm install'
                            sh 'npm run test'
                            sh 'npm run build'
                            echo 'Building frontend Docker image...'
                        }
                    }
                }
            }
        }

        stage('Deploy to Staging') {
            when {
                anyOf {
                    changeset "backend/**"
                    changeset "frontend/**"
                }
            }
            steps {
                echo 'Deploying to Staging...'
                // ステージング環境へのデプロイステップ
            }
        }
    }

    post {
        always {
            cleanWs()
        }
        success {
            echo 'Pipeline succeeded!'
        }
        failure {
            echo 'Pipeline failed!'
        }
    }
}
```

## 10.0 はじめに

新しい開発者がローカルでプロジェクトを実行するための、番号付きのシンプルなコマンドリストです。

### セットアップ手順

1. **リポジトリをクローンする**:

   ```bash
   git clone <repository-url> event-management-system
   ```

2. **プロジェクトルートに移動する**:

   ```bash
   cd event-management-system
   ```

3. **環境ファイルを作成する**:

   ```bash
   cp env.example .env
   ```

   ファイル内の変数を設定します。

4. **コンテナをビルドして起動する**:

   ```bash
   docker-compose up --build -d
   ```

5. **データベースマイグレーションを実行する**:

   ```bash
   docker-compose exec backend make migrate-up
   ```

6. **アプリケーションにアクセスする**:
   - フロントエンド: http://localhost:3000
   - バックエンド API: http://localhost:8080

### 開発コマンド

#### バックエンド

```bash
# テスト実行
make test

# アプリケーション起動
make run

# マイグレーション作成
make migrate-create NAME=create_users_table

# APIサーバーコード生成
make generate-api-server
```

#### フロントエンド

```bash
# 依存関係インストール
npm install

# 開発サーバー起動
npm run dev

# テスト実行
npm test

# APIクライアント生成
npm run generate-api-client
```

### トラブルシューティング

- **データベース接続エラー**: `docker-compose logs db` でログを確認
- **ポート競合**: `docker-compose down` でコンテナを停止してから再起動
- **マイグレーションエラー**: `make migrate-status` で現在の状態を確認
