# 開発手順

## 概要

このドキュメントは、イベント管理システムで機能を追加・修正する際の開発手順を説明します。
クリーンアーキテクチャ、DDD、CQRS の設計原則に従って開発を行います。

## バックエンド開発手順

### 1. 新機能追加の流れ

#### 1.1 ドメイン層（Domain Layer）

**関心を向けるファイル：**

- `backend/internal/domain/aggregate/` - 集約（Aggregate）
- `backend/internal/domain/errors.go` - ドメインエラー
- `backend/internal/domain/repository/` - リポジトリインターフェース

**開発手順：**

1. **集約の作成・修正**

   ```go
   // backend/internal/domain/aggregate/event.go
   type Event struct {
       // エンティティの属性
   }

   // ビジネスメソッド
   func (e *Event) Publish() error {
       // ビジネスルールの実装
   }
   ```

2. **ドメインエラーの追加**

   ```go
   // backend/internal/domain/errors.go
   var (
       ErrEventNameRequired = errors.New("event name is required")
   )
   ```

3. **リポジトリインターフェースの定義**
   ```go
   // backend/internal/domain/repository/event_repository.go
   type EventRepository interface {
       Save(ctx context.Context, event *aggregate.Event) error
       FindByID(ctx context.Context, id string) (*aggregate.Event, error)
   }
   ```

#### 1.2 アプリケーション層（Application Layer）

**関心を向けるファイル：**

- `backend/internal/application/command/` - コマンド（書き込み操作）
- `backend/internal/application/query/` - クエリ（読み取り操作）

**開発手順：**

1. **コマンドの作成**

   ```go
   // backend/internal/application/command/create_event_command.go
   type CreateEventCommand struct {
       Name        string    `json:"name"`
       Description string    `json:"description"`
   }

   type CreateEventCommandHandler struct {
       eventRepo repository.EventRepository
   }

   func (h *CreateEventCommandHandler) Handle(ctx context.Context, cmd CreateEventCommand) (*aggregate.Event, error) {
       // ドメインロジックのオーケストレーション
   }
   ```

2. **クエリの作成**

   ```go
   // backend/internal/application/query/list_events_query.go
   type ListEventsQuery struct {
       Status aggregate.EventStatus `json:"status"`
   }

   type ListEventsQueryHandler struct {
       eventRepo repository.EventRepository
   }
   ```

#### 1.3 インフラ層（Infrastructure Layer）

**関心を向けるファイル：**

- `backend/internal/infrastructure/repository/` - リポジトリ実装
- `backend/internal/infrastructure/persistence/` - データベース関連

**開発手順：**

1. **リポジトリ実装の作成**

   ```go
   // backend/internal/infrastructure/repository/memory_event_repository.go
   type MemoryEventRepository struct {
       events map[string]*aggregate.Event
   }

   func (r *MemoryEventRepository) Save(ctx context.Context, event *aggregate.Event) error {
       // メモリへの保存実装
   }
   ```

#### 1.4 インターフェース層（Interface Layer）

**関心を向けるファイル：**

- `backend/cmd/api/main.go` - API エンドポイント

**開発手順：**

1. **API エンドポイントの追加**

   ```go
   // backend/cmd/api/main.go
   func main() {
       e := echo.New()

       // 依存性注入
       eventRepo := repository.NewMemoryEventRepository()
       createHandler := command.NewCreateEventCommandHandler(eventRepo)

       // ルーティング
       e.POST("/events", func(c echo.Context) error {
           var req command.CreateEventCommand
           if err := c.Bind(&req); err != nil {
               return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
           }

           event, err := createHandler.Handle(context.Background(), req)
           if err != nil {
               return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
           }

           return c.JSON(http.StatusCreated, event)
       })
   }
   ```

### 2. 修正の流れ

1. **バグ修正の場合**

   - 該当する層のファイルを特定
   - ドメインロジックの修正は `domain/` 層
   - アプリケーションロジックの修正は `application/` 層
   - インフラの修正は `infrastructure/` 層

2. **機能拡張の場合**
   - 既存の集約にメソッドを追加
   - 新しいコマンド/クエリを作成
   - 必要に応じてリポジトリインターフェースを拡張

## フロントエンド開発手順

### 1. 新機能追加の流れ

#### 1.1 ページ・コンポーネントの作成

**関心を向けるファイル：**

- `frontend/src/app/(main)/` - メインアプリケーション
- `frontend/src/app/(auth)/` - 認証関連
- `frontend/src/components/` - 共有コンポーネント

**開発手順：**

1. **ページの作成**

   ```tsx
   // frontend/src/app/(main)/events/new/page.tsx
   "use client";
   import { useState } from "react";

   export default function CreateEventPage() {
     const [formData, setFormData] = useState({
       name: "",
       description: "",
       startDate: "",
       endDate: "",
     });

     const handleSubmit = async (e: React.FormEvent) => {
       e.preventDefault();
       // API呼び出し
     };

     return (
       <div>
         <h2>イベント作成</h2>
         <form onSubmit={handleSubmit}>{/* フォーム要素 */}</form>
       </div>
     );
   }
   ```

2. **コンポーネントの作成**

   ```tsx
   // frontend/src/components/EventForm.tsx
   interface EventFormProps {
     onSubmit: (data: EventFormData) => void;
     loading?: boolean;
   }

   export function EventForm({ onSubmit, loading }: EventFormProps) {
     // フォームコンポーネントの実装
   }
   ```

#### 1.2 API クライアントの作成

**関心を向けるファイル：**

- `frontend/src/lib/api/` - API クライアント

**開発手順：**

1. **API 関数の作成**

   ```typescript
   // frontend/src/lib/api/events.ts
   export interface CreateEventRequest {
     name: string;
     description: string;
     start_date: string;
     end_date: string;
   }

   export async function createEvent(data: CreateEventRequest) {
     const response = await fetch("http://localhost:8080/events", {
       method: "POST",
       headers: {
         "Content-Type": "application/json",
       },
       body: JSON.stringify(data),
     });

     if (!response.ok) {
       throw new Error("Failed to create event");
     }

     return response.json();
   }
   ```

#### 1.3 状態管理の実装

**関心を向けるファイル：**

- `frontend/src/store/` - グローバル状態
- `frontend/src/hooks/` - カスタムフック

**開発手順：**

1. **カスタムフックの作成**

   ```typescript
   // frontend/src/hooks/useEventForm.ts
   import { useState } from "react";
   import { createEvent } from "@/lib/api/events";

   export function useEventForm() {
     const [loading, setLoading] = useState(false);
     const [error, setError] = useState<string | null>(null);

     const handleSubmit = async (data: CreateEventRequest) => {
       setLoading(true);
       setError(null);

       try {
         await createEvent(data);
         // 成功処理
       } catch (err) {
         setError(err instanceof Error ? err.message : "Unknown error");
       } finally {
         setLoading(false);
       }
     };

     return { handleSubmit, loading, error };
   }
   ```

### 2. 修正の流れ

1. **UI 修正の場合**

   - 該当するページ・コンポーネントファイルを修正
   - スタイリングの修正は該当コンポーネント内で行う

2. **ロジック修正の場合**
   - カスタムフックや API クライアントを修正
   - 状態管理の修正は該当するフック内で行う

## 開発のベストプラクティス

### 1. レイヤー間の依存関係

- **ドメイン層**は他の層に依存しない
- **アプリケーション層**はドメイン層のみに依存
- **インフラ層**はアプリケーション層のインターフェースを実装
- **インターフェース層**はアプリケーション層を使用

### 2. エラーハンドリング

- ドメインエラーは `domain/errors.go` で定義
- アプリケーション層でエラーを適切に処理
- フロントエンドでユーザーフレンドリーなエラーメッセージを表示

### 3. テスト

- 各層で単体テストを作成
- ドメインロジックは特に重要
- インテグレーションテストで層間の連携を確認

### 4. 命名規則

- **ファイル名**: スネークケース（例: `create_event_command.go`）
- **構造体名**: パスカルケース（例: `CreateEventCommand`）
- **メソッド名**: パスカルケース（例: `Handle`）
- **変数名**: キャメルケース（例: `eventRepo`）

## トラブルシューティング

### よくある問題

1. **import エラー**

   - モジュールパスが正しいか確認
   - `go mod tidy` を実行

2. **依存性注入エラー**

   - インターフェースと実装の整合性を確認
   - 依存関係の方向を確認

3. **API 通信エラー**
   - CORS 設定を確認
   - エンドポイントの URL を確認
   - リクエスト/レスポンスの形式を確認

### デバッグ手順

1. バックエンドのログを確認
2. フロントエンドのコンソールログを確認
3. ネットワークタブで API リクエストを確認
4. 各層の単体テストを実行
